\subsection{Activation Phase Design}\label{activation_phase_design}

\emph{Activation} is the phase in the life-cycle of an update proposal where it
might come into effect.
%
This phase follows the approval phase where the submitted implementations are
reviewed by the expert pools (who are delegated by the community).
%
Through a voting process the experts decide whether an implementation of a
software update will proceed to the activation phase or whether it will be
rejected.

An update can be of four types:
\begin{description}
	\item[Parameters] which are updates that change the system parameters.
	\item[Consensus] which are updates that change the consensus rules. For 
	instance
	changes in the transaction or block validation rules, or changes in the fork
	resolution rules. As an extreme example, even the underlying consensus
	protocol could be changed (for instance, going from Ouroboros classic to
	Ouroboros BFT).
	\item[Application] which are updates of applications in the Cardano 
	ecosystem:
	nodes, wallets, explorers, etc. Application updates do not change the
	blockchain protocol.
	\item[Cancellation] which are special kind of update proposals that can be 
	used
	to cancel other \emph{approved} proposals\footnote{For non-approved 
	proposals
		the expert pools can simply reject said update}.
\end{description}

Application updates do not require synchronization among the nodes of the
blockchain. Since this update does not affect consensus or might not even be
related to a software update for a node, the community can upgrade to a new
version of a given application as soon as it is (stably) approved.

A protocol-parameters update comes into effect \emph{at the beginning of a new
	epoch}. The nodes do not need to install new software, since the current
running version can update the parameters as prescribed in an approved update
proposal.

A consensus-update requires that the parties \emph{synchronize} prior to its
activation to avoid a chain split due to lack of consensus. In addition, before
the activation, we need to make sure that certain security assumptions hold,
like the fact that enough honest stake has upgraded.
%
To this end, the activation phase synchronizes participants to make sure that at
least a certain portion of the honest stake will activate the update at the same
time, which is a necessary condition to ensure that the upgraded ledger will be
secure.
%
In this context, activation of an update means that the protocol version that it
specifies becomes the current version of the blockchain.

The stake that can endorse is the stake delegated to stake pools, which is the
stake that is considered for selecting block producers.

Note that a consensus-update can also specify parameters update. In this case
the new software needs to be installed and run on the nodes, and the new
software must apply, at the beginning of an epoch, the parameters updates that
the update proposal dictates.

Additionally, consensus update must specify where the code and binaries that
run the new protocol can be obtained.

All parameters and consensus proposals must specify:
\begin{itemize}
	\item The version that they supersede. The proposal can only be applied to 
	this
	version.
	\item The (hash of the) proposal they supersede. Update proposals in the
	approval phase can have the same version, so proposals need to disambiguate
	the proposal they supersede. This allows us to avoid a situation in which a
	proposal depends on a given version, but also (implicitly) on a particular
	implementation of that version. If we do not make this dependency implicit,
	then we risk having an update being applied on the wrong version.
	%
	We cannot on the other hand, enforce uniqueness of versions in update
	proposals, since we risk having malicious actors organizing a denial of
	service attack that prevents honest proposals from entering the system.
	%
	Note that having a proposal specify the proposal it supersedes require that 
	we
	start with a Genesis (implementation) proposal.
\end{itemize}

When a parameters or consensus proposal is approved\footnote{Cancellation and
	application update proposals come into effect immediately after being
	approved.} it enters a \emph{priority queue} where it waits to be activated.
The priority of the queue is determined by the update proposal's versions. A
proposal with lower version will activate \textbf{before} a 
proposal with a
higher version.
%
We call the proposals in the activation queue the \emph{approved proposals}.

Proposals \textbf{must increase} the current \emph{protocol-version} that the
chain supports. The protocol version consists of two components:
\begin{enumerate}
	\item The major version, which is used to specify hard-forks.
	\item The minor version, which is used to specify soft-forks.
\end{enumerate}

The update system guarantees that the protocol versions can only strictly
increase. In this way, the update system can rely on the update proposal's
protocol-version and its declared predecessor version to:
\begin{itemize}
	\item Determine priorities: a lower version (higher priority) is activated 
	before a higher version (lower priority) one; specifying the version gives 
	us a 
	simple way to specify urgency.
	\item Resolve conflicts: a proposal declares \textbf{one and only one} 
	version
	that it supersedes (its predecessor). Thus a proposal is in conflict with 
	all
	others except the one that it supersedes.
	\item Check dependencies: a proposal depends only on the one it supersedes.
\end{itemize}
This design decision requires:
\begin{itemize}
	\item The implementers to pick exactly one version their update is 
	compatible
	with, and determine which version their update should receive.
	\item The experts to check the version that an update has, and the 
	compatibility
	with the version it supersedes.
\end{itemize}

Protocol-versions of update proposals do not need to be unique. 
%However, if two
%proposals with the same version are in the approval phase in a given slot, then
%the experts can \textbf{vote for at most one of them}. This guarantees that at
%any slot only one proposal per-version can make it to the activation phase
%since:
%\begin{itemize}
%\item The expert pools can vote for one proposal with the same version at the
%  same slot.
%\item A majority of stake is required to approve the proposal.
%\nnote{This is not true. The requirement is to have stake in 
%favor above the threshold, which might be below majority i.e., 51\%. so both 
%proposals might exceed the threshold ang get approved}

%\end{itemize} 

If two proposals with the same version are in the approval phase and both are 
approved, then the last one entering the activation phase, will survive (see 
section \ref{sec:cancellations} on cancellations). In the unlikely case, where 
the two proposals coincide in their voting period ends and thus are approved at 
the very same slot, then we resolve this conflict by choosing the one with the 
higher stake in favor to enter the activation queue. In the even more unlikely 
case, where both have the same stake in favor, then we choose the proposal with 
the greatest id (proposal hash) to enter the activation queue.

The approved proposal at the front of the activation queue will enter the
\emph{endorsement period}, if it supersedes the current version (see section 
\ref{sec:entering-the-endorsement-phase} ).
%
There can be \emph{at most one proposal} in the endorsement period at any time.
%
This is to avoid the stake of the stakeholders being split among competing
proposals during endorsement, and thus, when changes take effect.
%
We call a proposal that is in the endorsement period the \emph{candidate
	proposal}.

If the new candidate proposal is a consensus-update, the block producers can
start \emph{endorsing} it. An endorsement is a special metadata field in the
block, and can be set only by the block producers. An endorsement signals the
fact that a node has downloaded and installed the software that implements the
update.
%
If the proposal gathers enough endorsements, then it can be
\emph{scheduled-for-activation}.
%
If the candidate proposal does not need endorsements, i.e. it is a protocol
parameters update, it becomes immediately scheduled.

A scheduled proposal \textbf{waits} to be activated \textbf{till the first slot
	of the next epoch}. In case of application updates, the proposal does not 
	need
to be activated. The ledger simply records its approval.

The next sub-sections describe the details of the activation protocol outlined
above.

\subsubsection{Entering the endorsement period}
\label{sec:entering-the-endorsement-phase}

An update proposal can enter the endorsement period if two conditions are met:
\begin{enumerate}
	\item It is at the front of the priority queue (i.e. it is has the lowest
	version among the proposals queue).
	\item The version and proposal hash that the proposal declares to supersede 
	must
	be \textbf{the same} as the current version.
\end{enumerate}
Once in the endorsement period, \textbf{it might return to the queue} if a new
update proposal is approved and ends up in front of the priority queue (which
means that the newly approved proposal has a lower version than the current
candidate).

\subsubsection{Endorsements of consensus updates}
\label{sec:endorsemnts}

Only a consensus-update needs endorsements, since it requires nodes to download
and install new software, and signal that they are ready to run the new version.
A consensus-update proposal has a \emph{safety lag} associated with it, which is
a time window that ensures sufficient time is provided to the parties to
download and deploy the candidate proposal. This safety lag determines the
duration of the endorsement period and \textbf{must be specified in number of
	epochs}. As a result, the end of the safety lag coincides with the end of an
epoch.

When a consensus-update proposal becomes a candidate, block producers can start
endorsing it. The stake associated with the keys endorsing the proposal is
tallied $2k$ blocks before the end of an epoch, where $k$ is maximum
\emph{number of blocks} the chain can roll back (see
Section~\ref{sec:on-cutoff-points-for-endorsements}). We consider the stake
\textbf{at the slot in which we tally}. We have two activation thresholds
depending on the epoch in which the tally takes place:
\begin{itemize}
	\item If the next epoch does not coincides with the end of the safety lag, 
	then
	this threshold is the \emph{adoption threshold} ($\tau_A$).
	\item If the next epoch coincides with the end of the safety lag, then this
	threshold is set to $51\%$.
\end{itemize}

Once we sum up the stake endorsing a proposal there are three possibilities:
\begin{enumerate}
	\item If the proposal has not gathered enough endorsing stake then:
	\begin{enumerate}
		\item If the safety lag expires on the next epoch then the proposal is
		canceled.
		\item If the safety lag does not expire on the next epoch then the 
		proposal
		can continue to be endorsed on the next epoch. The endorsements are 
		carried
		over.
	\end{enumerate}
	\item If the proposal has gathered enough endorsing stake, then it is
	\emph{scheduled for activation} at the beginning of the next epoch.
\end{enumerate}

Consensus and parameters updates get activated \emph{at the beginning of an
	epoch}. The reason for this is that the ledger and consensus rules rely on
these to be stable during any given epoch.

The cancellation\footnote{Note that we classify expired proposals, i.e.
	proposals that did not get enough endorsements at the end of the safety lag,
	as canceled proposals.} or activation of a proposal causes its removal from
the activation queue, and the next implemented proposal in the queue, if any, to
become the new candidate and enter the endorsement period.

A proposal being endorsed can go back to the queue (see
Section~\ref{sec:the-queue}). In this case the endorsements for this proposal
are discarded.

\subsubsection{Parameters update}
\label{sec:parameters-update}

Parameters-update proposals determine new values for the (existing) protocol
parameters. The current version of the software can deal with this sort of
updates, and therefore there is no need for the nodes to download and install
software, and thus no need for an endorsement period. However, they can only be
activated at beginning of an epoch. Parameters-update must also wait in the
activation queue.

A protocol parameters update must have a corresponding approved SIP, which
justifies the need for changing the parameter values. The submitted
implementation (UP) specifies the new values and the new protocol version
associated to these parameters. Both SIP and UP describe the parameters change.
The SIP does this in an abstract way, e.g. ``change maximum block size to 1MB'',
whereas the UP describes this change in a concrete way, e.g.
\texttt{maxBlokcSize = 1024}.

Note how, unlike Byron, the activation of one parameter update does not
automatically eliminate all the other pending parameters updates. We rely on the
versioning scheme for resolving conflicts. For instance, assume the current
protocol version is \texttt{1.0.0}. If updates with versions \texttt{1.1.0} and
\texttt{1.2.0} both change a parameter \texttt{p}, activating \texttt{1.1.0}
does not necessarily causes \texttt{1.2.0} to be discarded. It all depends on
the version the \texttt{1.2.0} supersedes. If it supersedes \texttt{1.0.0}, then
it will be canceled since the current version is now \texttt{1.1.0} and versions
can only increase. However \texttt{1.2.0} could declare that it supersedes
version \texttt{1.1.0}, in which case it can be activated after this version
(for instance in the next epoch).

\subsubsection{Application updates}
\label{sec:software-only-updates}

Application updates are not related to protocol updates, and therefore the do
not enter the activation phase.
%
Upon approval of an application update the ledger simply records this event.
%
The dependencies between applications and protocol versions has to be managed
off chain, and it is the responsibility of developers (who implement the
updates) and experts. The update system can provide metadata for specifying the
dependencies and/or conflicts of an application with the rest of the ecosystem,
but the update system will not check this.

Just like the other kind of updates, application updates must have a
corresponding approved SIP and implementation.

\subsubsection{Explicit cancellation}
\label{sec:explicit-cancellation}

A proposal can be explicitly canceled. This allows the experts and community to
cancel an approved implementation after a (significant) problem with it was
discovered.

An explicit cancellation is submitted as a SIP that must justify the reason for
canceling the proposals. When submitted as an update proposal (UP), the
cancellation must specify the proposals that it will cancel if approved.

The explicit cancellation also goes through the ideation and approval phases,
however, the explicit cancellation \emph{immediately cancels} the proposals it
refers to once it gets approved by the expert pools in the approval phase.

Cancellation proposals have no next-versions associated with it. They only
specify the hash of the implementations they cancel.

\subsubsection{Cancellations}
\label{sec:cancellations}

There are several factors that can cause a proposal to be canceled:

\begin{itemize}
	\item The proposal is explicitly canceled by a cancellation proposal that 
	made
	it past the approval phase.
	\item The proposal is overridden by another proposal with the same version 
	that
	made it through the approval phase. If the experts approve such proposal, 
	then
	this gives a strong indication that the older proposal should be discarded.
	Note that even though the system guarantees that only one proposal 
	per-version
	will get approved in any given slot (see section \ref{sec:activation-phase} 
	on how we resolve the conflict of proposals of the same version approved in 
	the same slot), 
	there might be proposals approved with
	the same version as a proposal approved in a previous slot.
	\item The proposal supersedes a version that can never follow. Protocol 
	versions
	increase monotonically. So if an update depends on a version that is lower
	than the current version we know for sure that such version can never be 
	seen
	on the chain, and therefore the proposal that depends on this version can be
	discarded.
\end{itemize}

If the candidate proposal already got the required endorsements (which means
that the cancellation arrived at or later than the slot at which the tally
occurred, this is $2k$ blocks before the end of an epoch), and is waiting to
be activated, then the cancellation update cannot stop it. In this case, a new
software update must be implemented and submitted that will correct the
identified problem.

If a candidate proposal is a parameters update, which means that does not need
endorsements, but the cancellation arrives \textbf{after} $2k$ blocks before
the end of the epoch, then it cannot be canceled either for the reasons given in
Section~\ref{sec:on-cutoff-points-for-endorsements}.

Nodes that upgraded to a canceled version can continue to operate normally
following the current version since the upgraded version \textbf{must} be able
to follow the current ledger and consensus rules.
%
Then it is up to the node operators to revert back to the previous version, or
continue using the software version that can also validate the protocol version
that got discarded. The ledger rules \textbf{shall ensure} that this discarded
protocol version is never applied.

\subsubsection{The queue}
\label{sec:the-queue}

Approved proposals enter an activation priority queue. The order of the queue is
determined by the proposal's versions. This queue \textbf{shall not} contain any
duplicated versions. If a proposal with the same version as a proposal from the
queue gets approved, then:

\begin{enumerate}
	\item If the old proposal (the one in the queue\footnote{Note that only the
		proposal in front of the queue can receive endorsements.}) does not have
	enough endorsements by the time the new proposal is approved, then the old
	proposal is canceled.
	\item If the old proposal has enough endorsements, then the new proposal is
	canceled.
\end{enumerate}


If a proposal with a lower version than the current candidate enters the queue
(i.e. the front of the queue changes), then we also have two situations:

\begin{enumerate}
	\item If the candidate proposal does not have enough endorsements, then it 
	is
	put back in the queue, and the new proposal becomes the new candidate. If 
	this
	new candidate gets approved then the old proposal will be canceled (since it
	will supersede a version lower than the current version). However, since it 
	is
	possible that the new proposal gets canceled (for instance due to lack of
	enough endorsements), we leave the old proposal in the queue.
	\item If the candidate proposal has enough endorsements, then the new 
	proposal
	gets discarded (since it will be superseding an older version that will 
	never
	be adopted since versions increase monotonically).
\end{enumerate}

\subsubsection{On cut-off points for endorsements}
\label{sec:on-cutoff-points-for-endorsements}

The ledger layer must provide future information about a part of its state. In
particular, it should be able to tell up to $k$ blocks in the future if a
new protocol version will be activated. To this end, we require that the
\emph{last endorsement} required for meeting the adoption threshold \emph{is
	stable} $k$ blocks before the end of the epoch. This means that
endorsements for a given proposal for a given epoch are considered up to
$2k$ blocks before the end of that epoch. This is not to say that the
endorsements after this cut-off point will not be considered, just that they
will in the next epoch.

To see why this is required, consider a last endorsement (required to meet the
threshold) arriving between $2k$ blocks and $k$ blocks before the end of an
epoch, which will happen at block number $b_e$. If the ledger is asked between
blocks $b_e - k$ and $b_e$ whether a new version will be activated at $b_e$, the
answer depends on the stability of the last endorsement. If it is not stable,
then replying ``yes'' might be incorrect, since we can roll back and switch to a
fork where that endorsement never occurred. If we reply ``no'', then this might
also be incorrect if we continue in that fork.

\subsection{Open questions}
\label{sec:open-questions}

\begin{itemize}
	\item Is the requirement that updates specify \textbf{exactly} the version 
	it
	supersedes too restrictive? Do we foresee lifting this restriction any time
	soon? If so we might want to revisit the activation phase described here.
	\item Is there a problem in supporting software updates for one code base 
	only?
	\item Do we see a problem with making the protocol permissive and allow any
	version to be endorsed? Invalid endorsements, i.e. endorsements that don't
	refer to an existing candidate version, will simply be discarded.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "decentralized-updates"
%%% End:
