\section{Introduction}
Software updates are everywhere. The most vital aspect for the sustainability of
any software system is its ability to effectively and swiftly adapt to changes;
one basic form of which are software updates. Therefore the adoption of software
updates is at the heart of the lifecycle of any system and blockchain systems
are no exception. Software updates might be triggered by a plethora of different
reasons: change requests, bug-fixes, security holes, new-feature requests,
various optimizations, code refactoring etc.

More specifically, for blockchain systems, a typical source of change are the
enhancements at the consensus protocol level. There might be changes to the
values of specific parameters (e.g., the maximum block size, or the maximum
transaction size etc.), changes to the validation rules at any level
(transaction, block, or blockchain), or even changes at the consensus protocol
itself. Usually, the reason for such changes is the reinforcement of the
protocol against a broader scope of adversary attacks, or the optimization of
some aspect of the system like the transaction throughput, or the storage cost
etc.

In this paper, our focus is on the software update mechanism of stake-based
blockchain systems. We depart from the traditional centralized approach of
handling software updates, which is the norm today for many systems (even for
the ones that are natively decentralized, like permission-less blockchain
systems) and try to tackle common software update challenges in a decentralized
setting. We consider the full lifecycle of a software update, from conception to
activation and propose decentralized alternatives to all phases. Essentially, we
introduce a \emph{decentralized maintenance} approach for stake-based blockchain
systems.

\paragraph{Problem Definition.}
Traditionally, software updates for blockchain systems have been handled in an
ad-hoc, centralized manner: somebody, often a trusted authority, or the original
author of the software, provides a new version of the software, and users
download and install it from that authority's website. Even if the system
follows an open source software development model, and therefore an update can
potentially be implemented by anyone, the final decision of accepting, or
rejecting, a new piece of code is always taken by the main maintainer(s) of the
system, who essentially constitutes a central authority. Even in the case where
the community has initially reached consensus for an update proposal (in the
form of an \emph{Improvement Proposal} document), through the discussion that
takes place in various discussion forums, still it remains an informal,
\say{social} consensus, which is not recorded as an immutable historical event
in the blockchain and the final decision is always up to the code maintainer.
Moreover, the authenticity and safety of the downloaded software is usually
verified by the digital signature of a trusted authority, such as the original
author of the software. Hence what does it take to decentralize software
updates? What are the critical decisions that must be made collectively and not
centrally? What is a secure update protocol that will enable this
decentralization? How can we avoid chain-splits and ensure a secure transition
to an updated protocol? What does it even mean to have a "secure activation"?
How can we enable a meta-data driven update logic that will smoothly deal with
priorities, version dependencies, conflicts and emergencies? Finally, how can
we smoothly incorporate a new update system into the Cardano node?

\paragraph{Our contributions.}
We put forth a novel mechanism for realizing decentralized software updates. In
our proposed scheme, an update proposal can be submitted by anyone
who can submit a transaction to the blockchain. The decision of which update
proposal will be applied and which will not is taken collectively by the
community and not centrally. Thus, the roadmap of the system is decided
jointly. Moreover, this process is no longer an informal discussion process,
but part of an \emph{update protocol}. All relevant events generated are stored
within the blockchain itself, and thus recorded in the immutable update history
of the system. Moreover, the role of the code maintainer, who used to take
decisions on the correctness of the submitted new code and guarantees the
validity of the downloaded software, is replaced by the stakeholders' community.

In particular in this work,
\begin{itemize}
  \item We identify what are the critical decisions in the software lifecycle
	 and then propose a secure software update protocol that covers the
	\emph{full lifecycle} of a software update from the ideation phase (the
	moment in which a change to the blockchain protocol is proposed) to the
	actual activation of the updated blockchain protocol, which enables
	decentralized decision making in all critical decisions.
	\item We propose a liquid democracy scheme, based on delegated voting to
	\emph{experts}, for all the critical, but also deeply technical, decisions
	for software updates.
	\item We formally define what it means for a \emph{decentralized} software
	update system to be secure and propose (in \cite{secure_activation}) two
	secure 	activation protocols with different trade-offs.
  % TODO: check: are we describing the protocol in this document? If not it
  % should not be part of the results we enumerate in the abstract.
	\item We deal with all the complexity and details of updates activation,
	such as priorities, version dependencies, conflicts resolution and
	emergency handling
	and propose	a simple design for smoothly incorporating all these into
	our update logic.
	\item We perform threshold analysis for voting as well as activation, in
	order to 	achieve both properties of safety and liveness, which we define
	in detail.
	\item We carry out a performance analysis that has shown that our update
  protocol is both linearly scalable in the number of participants and does not
  impact negatively the performance of the underlying blockchain.
	\item We propose an architecture for integrating an update mechanism within
	the Cardano node \cite{cardano} and in particular within the ledger layer,
	so that we
	achieve the principles of modularity and information hiding.
  % TODO: check: do we propose an architecture? we've integrated the whole
  % thing, why not simply *describing* the integration, including the
  % architecture?
  \item describe the implementation of our ideas into a research prototype that
  was integrated into Cardano.
  \item describe a prototype validation methodology based on a trace-enabled
	property-based testing framework that we have developed for this purpose.
\end{itemize}

%
%In the context of software updates for public stake-based blockchain systems,
%we introduce the capability to take stake-based decisions
%%\mnote{I am not sure that we should talk about stake majority-based decision.
%%Indeed, we later discuss the possibility of setting the threshold (that
%%defines
%%whether a proposal should be accepted or not) to be anything greater than
%%$52\%$}
% based on: a) the software update priority, b) the correctness of the new
%code, c) the maintenance of the code base and d) the authenticity and safety
%of
%the downloaded software. We introduce the problem of then activating the
%changes on the blockchain without risking a chain split
%%, as part of the consensus protocol and recorded on-chain, while at the same
%%time fulfilling software dependencies requirements, resolving version
%%conflicts, enabling different update policies based on update metadata and
%%avoiding chain splits when updates are activated
% as the \emph{decentralized software updates problem}, and put forth the first
%solution to this problem. In addition, we investigate how to enable different
%update policies based on the software update context (i.e., update metadata)
%and at the same time fulfill software dependency requirements and resolve
%conflicts (cf. Appendix \ref{appxupdlogic}).
%%\mnote{The latest might become on of the main focus of the paper. We should
%%highlight that.}


%Contributions




%\paragraph{Problem Definition.}  Traditionally, software updates have been handled in an ad-hoc, centralized manner: Somebody, often
%a trusted authority, or the original author of the software, provides a new version of the software, and users
%download and install it from that authority's website. However, this approach is clearly not decentralised, and
%hence jeopardizes the decentralized nature of the whole system: In a decentralized software update mechanism,
%proposed updates can be submitted by anyone (just like anyone can potentially create a transaction in a blockchain).
%The decision of which update proposal will be applied and which wont, is taken collectively by the community
%and not centrally. Thus, the road-map of the system is decided jointly. Moreover, there is no central code
%repository, nor there is some main software maintainer, who decides on the code. All versions of the code
%are distributed and only local copies exist, in the same manner that the ledger of transactions is distributed in
%blockchain. The decentralized software update system must reach a consensus, as to what version is the current
%one (main branch) and which code branch will be merged into main. Finally, the decentralized software update
%system guarantees the authenticity and safety of the downloaded software, without the need to have some central authority
%to sign the code, in order to be trusted


%The traditional way of handling software updates is neither decentralized nor secure
%\begin{itemize}
%\item No standard way to propose updates
%\item Not a decentralized and democratic way to reach at a consensus on update priorities. Only \enquote{social consensus} is reached via social media. This is unstable and prone to chain splits.
%\item No essential auditing and verifiability of the agreement
%\item No standard way to record the immutable history of all these events (proposals,agreement, \item activation of updates)
%\item No standard method for security guarantees for the software installed
%\item No standard way to resolve conflicts and respect dependencies
%\item No standard Update metadata
%\item One-size-fits-all for all \enquote{types} of changes (bugs,CRs)
%\item Hard-forks are the norm
%\end{itemize}

%\paragraph{Goal of the paper.} In this paper, we propose a secure software
%update mechanism that enables a decentralized approach to the blockchain
%software updates problem. We examine all phases in the lifecycle of a software
%update and propose practical decentralized alternatives that can be adopted in
%the real world. These alternatives substitute any \emph{central authority}
%with
%the \emph{stakeholders' community}. Moreover we describe the integration of
%such a mechanism into the Cardano node \cite{cardano}. In order to enable this
%\emph{decentralization} of software updates, we exploit existing primitives
%that we combine in order to form a novel decentralized software updates
%protocol.
From a security perspective, we formally define what is a secure
activation of changes on a blockchain and prove the security of our protocol
with respect to this definition \cite{secure_activation}. Our update mechanism
ensures that:
%...A safe and secure decentralized software update system. %In other words, a system that will ensure that:
a) any stakeholder will always be able to submit an update proposal to be voted
by the stakeholders' community, b) an update proposal that is not approved by
the stakeholders
%\mnote{Also here, let's talk about a threshold $t$ greater than $51\%$ instead of stake majority since this is what we do}
 will never be applied, c) an update proposal that it is approved by the
 stakeholders will be eventually applied, d) an update proposal that the
 stakeholders decide has a higher priority than some other proposal will take
 higher priority,
 %e) downloaded software is authentic and safe,
 and finally e) it protects against chain splits during activation of the
 proposed updates and ensures a secure transition to the new version of the
 consensus protocol.

\import{./}{sections/related_work.tex}

\paragraph{Outline of the paper.}
In section \ref{sec:requirements}, we present the high-level requirements that
have driven our design. In section \ref{lifecycle}, we present our
decentralized approach for the lifecycle of a software update. In section
\ref{sec:update_governance}, we propose an update governance model based on
voting and delegation to experts. Section \ref{the_activation_of_changes},
deals
with the problem of the activation of changes on the blockchain in a secure
manner. Section \ref{sec:threshold_analysis}, performs a threshold analysis, in
order to achieve the properties of liveness and safety. Section
\ref{performance_considerations}, describes the performance analysis of our
update mechanism. Section \ref{architecture}, proposes an architecture for
integrating an update mechanism into Cardano. Finally, section
\ref{prototype_validation}, details our prototype validation approach presents
main results and
section \ref{sec:conclusion} draws main conclusions.
