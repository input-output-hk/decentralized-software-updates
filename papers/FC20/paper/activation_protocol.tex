\subsubsection{Candidate Protocol.}

Let $\ledger_1$ be the ledger that the parties are running and $\ledger_2$ be a new ledger.
In our construction we assume that $\ledger_1$ and $\ledger_2$ have the same common-prefix parameter $k$, the same chain-growth parameter $(\cg, s)$ and that they are secure under the same assumption $\asmp_1=\asmp_2$. We also assume that a block $B$ of $\ledger_1$ can be transformed into a \emph{special genesis block} $B'$ for $\ledger_2$. $B'$ is special because not only
it represents a valid genesis block for $\ledger_2$, but it also points to the state of $\ledger_1$ up to the block $B$. 
We use this special genesis block to guarantee that: 1) the state of $\ledger_1$ at the end of the activation is moved into the state of the new ledger
and 2) that we can use a block of $\ledger_1$ to bootstrap $\ledger_2$.
At a very high level our protocol works as follows. When enough parties have received the command $(\activate,\cdot)$ such that $\asmp_2$ holds,
a block of $\state_1$ is chosen as the special genesis block for $\ledger_2$. At this point the parties start running $\ledger_2$ and gradually abandon 
$\ledger_1$.
In the description of our update protocol we assume that there is a time $t^\upd$ such that $\asmp_2[t]$ holds for all $t\geq t^\upd=t_{P_1}+\Delta_1$.\footnote{We could require $\asmp_2$ to
hold only for bounded interval of time and our protocol would still work if this interval is large enough.}
We also assume that the parties in $\activep$ know an index $j$ such that when the $j$-th block is added to the state of $\ledger_1$ then $\asmp_2$ holds. 
More formally, at time $t^\upd$ the $j$-th block is part of $\ledger_1^{P_i}$ for all $P_i\in\activep$.
To ensure that $\asmp_2$ actually holds and to keep all the honest parties synchronized on the time $t^\upd$ (and on the index $j$) we use the approach proposed in Sec.~\ref{se:informal}.
In more details, $t^\upd$ represents either the time at which the adoption threshold is met, or it represents the time in which the safety lag period ends.
 

%\nnote{We can arrive at moment $t^\upd$, where $\ledger_2$ becomes secure, in two different ways: a) either the adoption threshold is met or b) the $j$-th block is added to the state of $\ledger_1$. If a) happens, then we dont need to wait for the $j$-th block to arrive. This last sentence does not "integrate" well with section 3.1}

We denote our update protocol with $\Pi$. In this, each honest party $P_i\in\activep$ at time $t^\upd$ executes the following steps.

\begin{myenumerate}
	%\item Upon receiving the input $(\activate, \cdot)$ wait until the $j$-th block of $\ledger_1$ becomes part of all the honest parties' ledger state (i.e., wait until $B_{j}$ becomes part of $\ledger_1^{P_i}[t]$ 
	%for all honest $P\in\activep$) and let $t^\upd$ be this time. \nnote{But if the adoption threshold is met, then we dont need to wait until $t^\upd$}
	\item Run $\ledger_1$ and when the $(j+k)$-th block $B^i_{j+k}$ becomes part of $\check \state_1^{P_i}[t]$ for some $t\geq t^\upd$
	start running also $\ledger_2$ using ${B^i}'$ as the candidate special genesis block (where ${B^i}'$ is generated using $B^i_{j+k}$).\footnote{Note that
	the special genesis block ${B^i}'$ obtained from $B^i_{j+k}$ could not be adopted as the genesis block for $\ledger_2$, because is not yet commonly agreed by all parties running $\ledger_2$.}
	\item Run $\ledger_2$ (and keep running $\ledger_1$) until there is an agreement on a special genesis block. That is, one of the candidate special genesis block 
	becomes part of $\state_2^{P_i}[t]$ for each honest $P\in\activep$ for some $t\geq t^\upd$.
	\item Stop running $\ledger_1$.
\end{myenumerate}



\begin{theorem}\label{th:main}
Let $\ledger_1$ and $\ledger_2$ be two ledgers that are secure under the assumption $\asmp_1=\asmp_2$, have common-prefix parameter $k$ and chain-growth parameter $(\cg, s)$ then
 $\Pi$ is a $(\Delta_1,\Delta_2)$-secure update system with $\Delta_1=k\cg^{-1}$ and $\Delta_2=k \cg^{-1} + k \cg^{-1}$.
\end{theorem}

We refer the reader to Appendix~\ref{se:proof} for the formal proof.
Although the above protocol is generic it has the limitation that the parameters
of $\ledger_1$ and $\ledger_2$ have to be the same. We could get rid of this limitation by requiring an additional property on $\ledger_2$.
If $\ledger_2$ supports temporary dishonest majority~\cite{DBLP:journals/corr/abs-1908-00427} then we do not need the assumption on the equality parameters to 
hold anymore.
Indeed, in this case we can modify $\Pi$ as follows. At time $t^\upd$ the honest parties wait for the block $B_j$ to be stable and then they start using it as a genesis 
block for $\ledger_2$.  We note that here it is crucial for $\ledger_2$ to support temporary dishonest majority since the adversary
could potentially see the genesis block way sooner than honest parties can see it. This means that there is an interval of time in which only the adversary is extending 
the genesis block and this corresponds to a situation in which the adversary has temporary dishonest majority.
For the best of our knowledge, the positive results regarding temporary dishonest majority are for PoW blockchain like Bitcoin as showed in~\cite{DBLP:journals/corr/abs-1908-00427}.
Another approach that can be currently applied to PoS protocol as well is the following. We let the parties in $\activep$ to run a multi-party computation (MPC) protocol
that guarantees output delivery in order to generate a special genesis block for $\ledger_2$. If we assume that the number of honest parties in $\activep$
represents the majority then they can execute this MPC protocol and then start running $\ledger_2$ using the obtained genesis block.







