\section{Update Logic}

\subsection{Decentralized Software Update Metadata} \label{appxmetadata}
\paragraph{Basic information.}The software update metadata should provide basic information about the software update, such as its title and a basic description. Also, the metadata should include the unique id of the SU, which can be the content hash of the SU and also the \emph{category tag} that will enable delegation for specialization, as we have described above. Other basic information include, the author of the SU, version information and a link pointing to the storage area, where the software update is stored, as well as a link to the metadata itself. Finally, since in our proposal, we distinguish software updates from SIPs to UPs, the basic metadata information should include a flag to separate one from the other.
\paragraph{Justification.} This is a very important part of the metadata of a software update, especially if this is a SIP. It is the information, with which the author of the update will try to convince the rest of the stakeholders on the merit of the proposed software update. Missing information in this part, or unclear justification statements, might cause the rejection of a proposal. The reason, the scope and the expected benefits of a software update must be clearly stated in this part.
\paragraph{Urgency.} This is where the priority requirement of a software update must be declared. If it is a bug-fix for example, then it should specify a severity level, in order to declare the urgency for deployment. Similarly, if it is a change request, a priority specification, will help the stakeholders prioritize the demand.
\paragraph{Consensus impact.} There are software updates that impact the consensus protocol and others that do not. For the former, it is important to declare the type of the change. If the validation rules of the protocol become less restrictive, then this is a \emph{hard fork} type of change. In this case, non-upgraded nodes reject the new type of blocks and thus there is a significant risk for a chain split. If the validation rules become more restrictive, then this is called a \emph{soft fork} type of change. In this case, the non-upgraded nodes accept the new type of blocks but the blocks generated buy these nodes are not accepted by the upgraded nodes. So, if the old nodes do not eventually upgrade, then they can not continue to issue new blocks. Finally, if the new validation rules are neither more restrictive, nor less restrictive, then we have a \emph{velvet fork} \cite{velvet}. This type of change does not entail the risk of a chain split. Naturally, the type of change is really important, because it signifies the risk for a \emph{chain split}. For example, a hard fork type of change entails much more risk for a chain split, in the case of nodes failing to upgrade on time, than a soft fork, or a velvet fork (which has no risk at all).
\paragraph{Implementation.} Next comes meta-information on the implementation of the software update. Possible examples could be, if this software update entails code development, or if it is a parameter change. For the latter, a distinction could be made between static and dynamic parameter changes. Essentially, dynamic parameter changes are \say{code-less} software updates - no deployment of new code is required. An explicit list of protocol parameters affected by the software update must be provided. This will be also exploited for the conflict resolution between software updates, mentioned below. Other aspects of the implementation have to do with the size and the complexity of a software update. Typically an estimation of the required man-effort for its implementation could be included.
\paragraph{Deployment.} The deployment of a software update is really critical, especially for those updates that impact the consensus protocol. This is because a lack of synchronization at the deployment phase might result into a chain split \say{by accident}. This part of the metadata comprises instructions on the deployment process, maybe deployment scripts, or declarative statements of the deployment process (if some automated software provisioning tool is used, e.g., ansible playbooks). Moreover, an estimation of the size of the deployment (in terms of man-effort required), would help to calculate parameters, such as the \emph{activation lag} described later on.
\paragraph{Rollback.} Symmetrically to the deployment, the metadata must include information for an un-install process, in the case of a problem. The type of information provided is similar to the deployment category.
\paragraph{Update constraints.} Software updates do not live in vacuum. They are strongly related to one another. In fact, there exist dependencies between software updates that if they are not followed, then the upgrade will fail. We call all the dependencies and the conflicts between software updates \emph{update constraints}. It is very crucial to clearly define the update constraints of a software update in its metadata. This will illustrate how feasible is a specific software update. For example, a dependency of a SU on another SU, which has not been implemented yet, is a clear indication of non-feasibility. Also, if two candidate software updates both change the value of the same protocol parameter, then they are in direct conflict and some sort of resolution should take place.
\paragraph{Update prerequisites.} In this part, we define other prerequisites apart from the ones that have to do with other software updates that we have discussed before and therefore, we can consider them as prerequisites from \say{external} factors. For example, platform requirements, software requirements (e.g., external libraries), or specific hardware requirements, in order for a software update to be applied successfully, should be mentioned in this section of the metadata.
\paragraph{Budget information.} Last but not least, comes the budget information. This is extremely useful information, especially, if the update system is backed up by a treasury system \cite{treasury} that will assume the funding of the implementation of the software update.

\subsection{Adoption Threshold} \label{appxadoption}
Let us assume that the adoption threshold of our software updates protocol is called $\tau_A$. %In order to enable update policies, we need to be able to adjust $\tau_A$ based on each software update's metadata. 
What would be the appropriate values for $\tau_A$? Take into account that by adjusting the value of $\tau_A$, we risk to cause a chain split for two distinct reasons: a) A too-low value of $\tau_A$ might result to a \emph{too-early activation}, which will result to the partition of the honest stake in two and a potential chain split\footnote{A partition of the honest stake also undermines the security of the underlying consensus protocol which assumes a minimum threshold $x$ of honest stake.}  and b) a too-high value of $\tau_A$ might result to a \emph{too-late activation}, giving the opportunity to adversaries to block an activation by refusing to signal. %Clearly the former is a safety problem, while the latter is a security problem. 
What is the allowable range of values for $\tau_A$, in order to mitigate these risks?

As we have seen from the voting section, we assume that the honest stake threshold of our software updates protocol is $h$. Also, in the same section we have seen that, if $x$ is the honest stake threshold of the underlying consensus protocol then $h \geq x$. Let us also assume that the actual percent of honest stake is $h_a$. Then, since $h$ is the minimum threshold, the following will hold: $ h_a \geq h$. Therefore, $h_a \geq x$. For the values that $\tau_A$ could take, we distinguish three distinct cases:
\begin{enumerate}
\item $\tau_A < x$
\item $\tau_A > h_a$
\item $ x \leq \tau_A \leq h_a$
\end{enumerate}
We know by definition that the minimum percent of honest stake that we can tolerate is $x$. In the first case, we allow the activation of changes to take place before this minimum of honest stake has the chance to upgrade. Thus, we risk to activate too-early, we partition the honest stake in two and therefore cause a chain split \say{by accident}. In the second case, we impose an adoption threshold $\tau_A$ that is greater than the actual honest stake. Therefore, in order to activate, we need to wait not only for the honest stake to upgrade but also for some part of the adversary stake, which of course may refuse to do. Therefore, by activating too-late, we give the opportunity to the adversary to block the activation forever.

Finally, in the third case, we do not have the risk of the activation blocking by an adversary, because we do not depend on the adversary's signals to meet the $\tau_A$ threshold. We depend only on honest stake and we have assumed from the beginning that all honest stake will eventually upgrade (and thus signal). However, we still run the risk to activate too-early and cause a chain split, but this time not \say{by accident}, but as an attack. Let us assume that, at a specific run, we achieve to meet the stake threshold $\tau_A$ of signals. This stake, in general, will comprise some honest part and some adversary part, $\tau_A = S_{honest} + S_{adversary}$. Clearly, in order to be safe from an accidental chain split, we need $S_{honest} \geq x$. This way, the \emph{longest chain rule} will ensure that the upgraded honest stake will produce the prevailing (i.e., longest) chain of blocks. So in order to be safe, as a minimum we need $S_{honest} = x$. In conclusion, in order to avoid both of the two problems described above, the adoption threshold $\tau_A$ should take values in the range $x \leq \tau_A \leq h_a$, with the assumption that the honest stake that has signaled, when the threshold is met, is at least $x$ ($S_{honest} \geq x$) , i.e., at least equal to the honest stake threshold of the consensus protocol.


 
