\section{Ledger Enhancements}

\subsection{Recording the History of Updates}
%\paragraph{motivation - what we want to do}
The historical tracking of software updates is very important. This is not only for the obvious reasons of reporting and statistical analysis but also for troubleshooting. Maintaining a log of all SUs is critical, when something has gone wrong and we want to investigate the root-cause. We use the ledger as the single version of the truth for software updates. But why is this necessary? Why we could not just use some off-chain logging mechanism to record all update events?

In a centralized setting, a simple logging mechanism would be enough. However, software updates in a decentralized setting, as we have seen, have a decentralized governance mechanism. In this case, we do not need only to record what software updates and when, these have been applied, but also how and when, they have been approved by the community. Moreover, this historical fact must be an immutable event that cannot be tampered with, because that would alter the evolution history of the system. Finally, in the decentralized approach there is no central owner of the code and thus, this history cannot be under central control. The historical records  must be stored in some repository, which must be inherently distributed. So, for these reasons, we propose the ledger as the home for the events generated in the lifecycle of a software update.

%\paragraph{scope}
To this end, we enhance the ledger with new types of events to be permanently recorded in the immutable history of updates. Moreover, we propose the maintenance of some local stake for software updates. This stake will provide necessary information to the update protocol without the need to access old blocks for reading individual events. This state can be calculated anytime from the events stored on the blockchain and therefore there is no need to store it on-chain. In this section, we will follow the course of a software update through out its lifecycle, as this has been described in the previous section, and describe in detail the events that will be generated along the way and those that need to be stored on-chain, in the distributed ledger, as well as to be maintained as local state.

%\todo{Nikos: What events will be stored 
%as transactions in the ledger? 
%Candidates are: Update Proposals, Votes ,Delegations ,Activations}

\subsection{Software Improvement Proposals}
   A software update starts its life with the issuance of a \emph{SIP document} by a stakeholder. This proposal must achieve the consensus of the majority of stake, through a voting mechanism, in order to become adopted... 
\subsubsection{Submission}
\subsubsection{Voting}
\subsubsection{Local State}

\subsection{Update Proposals}
\subsubsection{Submission}
\subsubsection{Voting}
\subsubsection{Local State}

\subsection{Activation Events}
\subsubsection{Signals}
\subsubsection{Adoption}
\subsubsection{Local State}

\subsection*{Update Proposals - Old stuff}
An Update Proposal can be issued by any party that owns stake. The party first creates the Update Proposal, hashes it, and uploads it to a decentralized storage service (to be discussed in later sections). Subsequently, they place the Update Proposal on the Blockchain.

We introduce a new type of transaction, an \emph{Update Issuance Commit Transaction (UICT)}, which commits the Update Proposal to the blockchain. Since it is a transaction it will be included into a block and thus into the ledger. The UICT contains the following data:

\begin{itemize}
\item[\textbf{commit:}] A salted commitment to the Update Proposal hash as well as the public saking key of the issuer. 
\begin{verbatim}
commit = H(salt || pk || H(Update Proposal))
\end{verbatim}
\item[\textbf{pk:}] The public key of the Update Proposal issuer.
\item[\textbf{sig:}] A signature on commit by the Update Proposal issuer public key pk
\end{itemize}

A UICT is broadcast to the network by the issuer. Upon receiving the UICT, the validators ensure that the signature sig verifies on the plaintext commit with public key pk and that the signing staking key pk satisfies a configurable minimum threshold of stake prior to relaying it or including it in their block. While relaying and inclusion is conditioned on threshold, if a UICT is included in a block generated by another miner, the block and UICT are accepted as valid regardless of stake. If a new UICT is broadcast pertaining to the same commitment and pk, it is rejected.

Once the UICT has been stabilized (by being buried under k blocks), the Update Issuer issues an \emph{Update Issuance Reveal Transaction (UIRT)}, which reveals the Update Proposal hash to the blockchain and makes it available for download. The UIRT contains the following data:

\begin{itemize}
\item[\textbf{proposal:}] 
The hash of the Update Proposal, 
i.e., %\verb|H(Update Proposal)|. 
\begin{verbatim}
H(Update Proposal).
\end{verbatim}
\item[\textbf{salt:}] The salt previously used in the UICT.
\item[\textbf{pk:}] The public key of the Update Proposal issuer.
\end{itemize}

Upon receiving a UIRT, any validator ensures that a respective UICT has been included in the most recent 12k blocks. On the one hand, this number has to be large enough to allow for block stability and liveness. On the other hand, it must be small enough so that unclaimed UIRTs can expire and garbage collected to avoid UTXO pollution; in addition, it must be small enough to bound the stake-shift that could have occured from UICT issuance to UIRT issuance. The validator finds the respective UICT by calculating 
\verb;commit = H(salt || pk || H(Update Proposal));  based on the data provided in the UIRT and looks for the commit value in the most recent 12k blocks. Furthermore, the validator ensures the pk in the UIRT matches the previously claimed pk in the UICT as well as within the UICT commit value.

The reason why the Update Proposal is issued on the blockchain in two stages, with UICT first and UIRT later, is so that the rightful author can claim authorship of a particular Update Proposal. If the Update Proposal hash were to be revealed immediately, a dishonest party could create a competing transaction, signing the same proposal with their own key to claim authorship. This follows a similar model to Namecoin name claims \cite{Namecoin}. If multiple valid UIRTs pertaining to the same commitment are received, only the first is included in the blockchain. Only the first such transaction is necessary, as any two UIRTs will necessary contain the same data due to it having been committed in the UICT and by the collision resistance property of the underlying hash function.

The slot at which the UIRT of an Update Proposal has been included is referred to as the \emph{issuance-time} of the proposal. After a UIRT transaction is validated, the node automatically attempts to download the Update Proposal, by hash, from the Decentralized Storage service. The node hashes the downloaded content to ensure that the hash included in the blockchain matches the hash of the downloaded content.

\subsection*{Update Proposal Validation  - Old stuff}
\nnote{We need to define the rules for a legitimate Update Proposal}
For example, a legitimate Update Proposal cannot have a dependency with an Update Proposal who has not been activated yet. So the version requirement of an Update Proposal must be the current adopted version.
\begin{verbatim}
sw_version_from == current_sw_version 
&&
prot_version_from == current_prot_version
\end{verbatim}

\nnote{Just validating an Update Proposal when it is revealed is not enough. It has to remain valid also right before activation}
