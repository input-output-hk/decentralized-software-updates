\section{Update protocol}

\subsection{Activation phase}
\label{sec:activation-phase}

\emph{Activation} is the phase in the life-cycle of an update proposal where it
might come into effect.
%
This phase follows the approval phase where the submitted implementations are
reviewed by the expert pools (who are delegated by the community).
%
Through a voting process the experts decide whether an implementation of a
software update will proceed to the activation phase or whether it will be
rejected.

An update can be of four types:
\begin{description}
\item[Parameters] which are updates that change the system parameters.
\item[Consensus] which are updates that change the consensus rules. For instance
  changes in the transaction or block validation rules, or changes in the fork
  resolution rules. As an extreme example, even the underlying consensus
  protocol could be changed (for instance, going from Ouroboros classic to
  Ouroboros BFT).
\item[Application] which are updates of applications in the Cardano ecosystem:
  nodes, wallets, explorers, etc. Application updates do not change the
  blockchain protocol.
\item[Cancellation] which are special kind of update proposals that can be used
  to cancel other \emph{approved} proposals\footnote{For non-approved proposals
    the expert pools can simply reject said update}.
\end{description}

Application updates do not require synchronization among the nodes of the
blockchain. Since this update does not affect consensus or might not even be
related to a software update for a node, the community can upgrade to a new
version of a given application as soon as it is (stably) approved.

A protocol-parameters update comes into effect \emph{at the beginning of a new
  epoch}. The nodes do not need to install new software, since the current
running version can update the parameters as prescribed in an approved update
proposal.

A consensus-update requires that the parties \emph{synchronize} prior to its
activation to avoid a chain split due to lack of consensus. In addition, before
the activation, we need to make sure that certain security assumptions hold,
like the fact that enough honest stake has upgraded.
%
To this end, the activation phase synchronizes participants to make sure that at
least a certain portion of the honest stake will activate the update at the same
time, which is a necessary condition to ensure that the upgraded ledger will be
secure.
%
In this context, activation of an update means that the protocol version that it
specifies becomes the current version of the blockchain.

The stake that can endorse is the stake delegated to stake pools, which is the
stake that is considered for selecting block producers.

Note that a consensus-update can also specify parameters update. In this case
the new software needs to be installed and run on the nodes, and the new
software must apply, at the beginning of an epoch, the parameters updates that
the update proposal dictates.

Additionally, consensus update must specify where the code and binaries that
run the new protocol can be obtained.

All proposals must specify:
\begin{itemize}
\item The version that they supersede. They proposal can only be applied to this
  version.
\item The (hash of the) proposal they supersede. Update proposals in the
  approval phase can have the same version, so proposals need to disambiguate
  the proposal they supersede. This allows us to avoid a situation in which a
  proposal depends on a given version, but also (implicitly) on a particular
  implementation of that version. If we do not make this dependency implicit,
  then we risk having a update being applied on the wrong version.
  %
  We cannot on the other hand, enforce uniqueness of versions in update
  proposals, since we risk having malicious actors organizing a denial of
  service attack that prevents honest proposals from entering the system.
  %
  Note that having a proposal specify the proposal it supersedes require that we
  start with a Genesis (implementation) proposal.
\end{itemize}

When a proposal is approved it enters a \emph{priority queue} where it waits to
be activated. The priority of the queue is determined by the update proposal's
versions. A proposal with lower version will activate \textbf{before} a proposal
with a higher version.
%
We call the proposals in the activation queue the \emph{approved proposals}.

Proposals \textbf{must increase} the current \emph{protocol-version} that the
chain supports. The protocol version consists of two components:
\begin{enumerate}
\item The major version, which is used to specify hard-forks.
\item The minor version, which is used to specify soft-forks.
\end{enumerate}

The update system guarantees that the protocol versions can only strictly
increase. In this way, the update system can rely on the update proposal's
protocol-version and its declared predecessor version to:
\begin{itemize}
\item Determine priorities: a lower version is activated before a higher one,
  specifying the version gives us a simple way to specify urgency.
\item Resolve conflicts: a proposal declares \textbf{one and only one} version
  that it supersedes (its predecessor). Thus a proposal is in conflict with all
  others except the one that it supersedes.
\item Check dependencies: a proposal depends only on the one it supersedes.
\end{itemize}
This design decision requires:
\begin{itemize}
\item The implementers to pick exactly one version their update is compatible
  with, and determine which version their update should receive.
\item The experts to check the version that an update has, and the compatibility
  with the version it supersedes.
\end{itemize}

Protocol-versions of update proposals do not need to be unique. However, if two
proposals with the same version are in the approval phase in a given slot, then
the experts can \textbf{vote for at most one of them}. This guarantees that at
any slot only one proposal per-version can make it to the activation phase
since:
\begin{itemize}
\item The expert pools can vote for one proposal with the same version at the
  same slot.
\item A majority of stake is required to approve the proposal.
\end{itemize}

The approved proposal at the front of the activation queue will enter the
\emph{endorsement period}.
%
There can be \emph{at most one proposal} in the endorsement period at any time.
%
This is to avoid the stake of the stakeholders being split among competing
proposals during endorsement, and thus, when changes take effect.
%
We call a proposal that is in the endorsement period the \emph{candidate
  proposal}.

If the new candidate proposal is a consensus-update, the block producers can
start \emph{endorsing} it. An endorsement is a special metadata field in the
block, and can be set only by the block producers. An endorsement signals the
fact that a node has downloaded and installed the software that implements the
update.
%
If the proposal gathers enough endorsements, then it can be
\emph{scheduled-for-activation}.
%
If the candidate proposal does not need endorsements, i.e. it is a protocol
parameters update, it becomes immediately scheduled.

In the case of parameters or consensus updates, a scheduled proposal
\textbf{waits} to be activated \textbf{till the end of the current epoch}. In
case of application updates, the proposal does not need to be activated. The
ledger simply records its approval.

The next sub-sections describe the details of the activation protocol outlined
above.

\subsubsection{Entering the endorsement period}
\label{sec:entering-the-endorsement-phase}

An update proposal can enter the endorsement period if two conditions are met:
\begin{enumerate}
\item It is at the front of the priority queue (i.e. it is has the lowest
  version among the proposals queue).
\item The version that the proposal declares to supersede must be \textbf{the
    same} as the current version.
\end{enumerate}
Once in the endorsement period, \textbf{it might return to the queue} if a new
update proposal is approved and ends up in front of the priority queue (which
means that the newly approved proposal has a lower version than the current
candidate).

\subsubsection{Endorsements of consensus updates}
\label{sec:endorsemnts}

Only a consensus-update needs endorsements, since it requires nodes to download
and install new software, and signal that they are ready to run the new version.
A consensus-update proposal has a \emph{safety lag} associated with it, which is
a time window that ensures sufficient time is provided to the parties to
download and deploy the candidate proposal. This safety lag determines the
duration of the endorsement period and \textbf{must be specified in number of
  epochs}. As a result, the end of the safety lag coincides with the end of an
epoch.

When a consensus-update proposal becomes a candidate, block producers can start
endorsing it. The stake associated with the keys endorsing the proposal is
tallied $2k$ blocks before the end of an epoch, where $k$ is maximum
\emph{number of blocks} the chain can roll back (see
Section~\ref{sec:on-cutoff-points-for-endorsements}). We consider the stake
\textbf{at the slot in which we tally}. We have two activation thresholds
depending on the epoch in which the tally takes place:
\begin{itemize}
\item If the next epoch does not coincides with the end of the safety lag, then
  this threshold is the \emph{adoption threshold} ($\tau_A$).
\item If the next epoch coincides with the end of the safety lag, then this
  threshold is set to $51\%$.
\end{itemize}

Once we sum up the stake endorsing a proposal there are three possibilities:
\begin{enumerate}
\item If the proposal has not gathered enough endorsing stake then:
  \begin{enumerate}
  \item If the safety lag expires on the next epoch then the proposal is
    canceled.
  \item If the safety lag does not expire on the next epoch then the proposal
    can continue to be endorsed on the next epoch. The endorsements are carried
    over.
  \end{enumerate}
\item If the proposal has gathered enough endorsing stake, then it is
  \emph{scheduled for activation} at the beginning of the next epoch.
\end{enumerate}

Consensus and parameters updates get activated \emph{at the beginning of an
  epoch}. The reason for this is that the ledger and consensus rules rely on
these to be stable during any given epoch.

The cancellation\footnote{Note that we classify expired proposals, i.e.
  proposals that did not get enough endorsements at the end of the safety lag,
  as canceled proposals.} or activation of a proposal causes its removal from
the activation queue, and the next implemented proposal in the queue, if any, to
become the new candidate and enter the endorsement period.

A proposal being endorsed can go back to the queue (see
Section~\ref{sec:the-queue}). In this case the endorsements for this proposal
are discarded.

\subsubsection{Parameters update}
\label{sec:parameters-update}

Parameters-update proposals determine new values for the (existing) protocol
parameters. The current version of the software can deal with this sort of
updates, and therefore there is no need for the nodes to download and install
software, and thus no need for an endorsement period. However, they can only be
activated at beginning of an epoch. Parameters-update must also wait in the
activation queue.

A protocol parameters update must have a corresponding approved SIP, which
justifies the need for changing the parameter values. The submitted
implementation (UP) specifies the new values and the new protocol version
associated to these parameters. Both SIP and UP describe the parameters change.
The SIP does this in an abstract way, e.g. ``change maximum block size to 1MB'',
whereas the UP describes this change in a concrete way, e.g.
\texttt{maxBlokcSize = 1024}.

Note how, unlike Byron, the activation of one parameter update does not
automatically eliminate all the other pending parameters updates. We rely on the
versioning scheme for resolving conflicts. For instance, assume the current
protocol version is \texttt{1.0.0}. If updates with versions \texttt{1.1.0} and
\texttt{1.2.0} both change a parameter \texttt{p}, activating \texttt{1.1.0}
does not necessarily causes \texttt{1.2.0} to be discarded. It all depends on
the version the \texttt{1.2.0} supersedes. If it supersedes \texttt{1.0.0}, then
it will be canceled since the current version is now \texttt{1.1.0} and versions
can only increase. However \texttt{1.2.0} could declare that it supersedes
version \texttt{1.1.0}, in which case it can be activated after this version
(for instance in the next epoch).

\subsubsection{Application updates}
\label{sec:software-only-updates}

Application updates are not related to protocol updated, and therefore the do
not enter the activation phase.
%
Upon approval of an application update the ledger simply records this event.
%
The dependencies between applications and protocol versions has to be managed
off chain, and it is the responsibility of developers (who implement the
updates) and experts. The update system can provide metadata for specifying the
dependencies and/or conflicts of an application with the rest of the ecosystem,
but the update system will not check this.

Just like the other kind of updates, application updates must have a
corresponding approved SIP and implementation.

\subsubsection{Explicit cancellation}
\label{sec:explicit-cancellation}

A proposal can be explicitly canceled. This allows the experts and community to
cancel an approved implementation after a (significant) problem with it was
discovered.

An explicit cancellation is submitted as a SIP that must justify the reason for
canceling the proposals. When submitted as an update proposal (UP), the
cancellation must specify the proposals that it will cancel if approved.

The explicit cancellation also goes through the ideation and approval phases,
however, the explicit cancellation \emph{immediately cancels} the proposals it
refers to once it gets approved by the expert pools in the approval phase.

Cancellation proposals have no next-versions associated with it. They only
specify the versions they cancel.

\subsubsection{Cancellations}
\label{sec:cancellations}

There are several factors that can cause a proposal to be canceled:

\begin{itemize}
\item The proposal is explicitly canceled by a cancellation proposal that made
  it past the approval phase.
\item The proposal is overridden by another proposal with the same version that
  made it through the approval phase. If the experts approve such proposal, then
  this gives a strong indication that the older proposal should be discarded.
  Note that even though the system guarantees that only one proposal per-version
  will get approved in any given slot, there might be proposals approved with
  the same version as a proposal approved in a previous slot.
\item The proposal supersedes a version that can never follow. Protocol versions
  increase monotonically. So if an update depends on a version that is lower
  than the current version we know for sure that such version can never be seen
  on the chain, and therefore the proposal that depends on this version can be
  discarded.
\end{itemize}

If the candidate proposal already got the required endorsements (which means
that the cancellation arrived at or later than the slot at which the tally
occurred, this is $2k$ blocks before the end of an epoch), and is waiting to
be activated, then the cancellation update cannot stop it. In this case, a new
software update must be implemented and submitted that will correct the
identified problem.

If a candidate proposal is a parameters update, which means that does not need
endorsements, but the cancellation arrives \textbf{after} $2k$ blocks before
the end of the epoch, then it cannot be canceled either for the reasons given in
Section~\ref{sec:on-cutoff-points-for-endorsements}.

Nodes that upgraded to a canceled version can continue to operate normally
following the current version since the upgraded version \textbf{must} be able
to follow the current ledger and consensus rules.
%
Then it is up to the node operators to revert back to the previous version, or
continue using the software version that can also validate the protocol version
that got discarded. The ledger rules \textbf{shall ensure} that this discarded
protocol version is never applied.

\subsubsection{The queue}
\label{sec:the-queue}

Approved proposals enter an activation priority queue. The order of the queue is
determined by the proposal's versions. This queue \textbf{shall not} contain any
duplicated versions. If a proposal with the same version as a proposal from the
queue gets approved, then:

\begin{enumerate}
\item If the old proposal (the one in the queue\footnote{Note that only the
    proposal in front of the queue can receive endorsements.}) does not have
  enough endorsements by the time the new proposal is approved, then the old
  proposal is canceled.
\item If the old proposal has enough endorsements, then the new proposal is
  canceled.
\end{enumerate}


If a proposal with a lower version than the current candidate enters the queue
(i.e. the front of the queue changes), then we also have two situations:

\begin{enumerate}
\item If the candidate proposal does not have enough endorsements, then it is
  put back in the queue, and the new proposal becomes the new candidate. If this
  new candidate gets approved then the old proposal will be canceled (since it
  will supersede a version lower than the current version). However, since it is
  possible that the new proposal gets canceled (for instance due to lack of
  enough endorsements), we leave the old proposal in the queue.
\item If the candidate proposal has enough endorsements, then the new proposal
  gets discarded (since it will be superseding an older version that will never
  be adopted since versions increase monotonically).
\end{enumerate}

\subsubsection{On cut-off points for endorsements}
\label{sec:on-cutoff-points-for-endorsements}

The ledger layer must provide future information about a part of its state. In
particular, it should be able to tell up to $k$ blocks in the future if a
new protocol version will be activated. To this end, we require that the
\emph{last endorsement} required for meeting the adoption threshold \emph{is
  stable} $k$ blocks before the end of the epoch. This means that
endorsements for a given proposal for a given epoch are considered up to
$2k$ blocks before the end of that epoch. This is not to say that the
endorsements after this cut-off point will not be considered, just that they
will in the next epoch.

To see why this is required, consider a last endorsement (required to meet the
threshold) arriving between $2k$ blocks and $k$ blocks before the end of an
epoch, which will happen at block number $b_e$. If the ledger is asked between
blocks $b_e - k$ and $b_e$ whether a new version will be activated at $b_e$, the
answer depends on the stability of the last endorsement. If it is not stable,
then replying ``yes'' might be incorrect, since we can roll back and switch to a
fork where that endorsement never occurred. If we reply ``no'', then this might
also be incorrect if we continue in that fork.

\subsection{Open questions}
\label{sec:open-questions}

\begin{itemize}
\item Is the requirement that updates specify \textbf{exactly} the version it
  supersedes too restrictive? Do we foresee lifting this restriction any time
  soon? If so we might want to revisit the activation phase described here.
\item Is there a problem in supporting software updates for one code base only?
\item Do we see a problem with making the protocol permissive and allow any
  version to be endorsed? Invalid endorsements, i.e. endorsements that don't
  refer to an existing candidate version, will simply be discarded.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "decentralized-updates"
%%% End:
